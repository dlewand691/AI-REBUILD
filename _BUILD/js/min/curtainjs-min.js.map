{"version":3,"sources":["../../../js/curtainjs.js"],"names":["window","addEventListener","curtains","Curtains","container","autoResize","watchScroll","renderingScale","check","top_of_element","$","offset","top","bottom_of_element","outerHeight","bottom_of_screen","scrollTop","innerHeight","top_of_screen","enableDrawing","disableDrawing","passive","planeElement","document","getElementsByClassName","plane","addPlane","vertexShaderID","fragmentShaderID","uniforms","time","name","type","value","initial","incrementer","scrollSpeed","scroll","baseSpeed","on","once","onRender","trigger"],"mappings":"AAAAA,OAAOC,iBAAiB,QAAQ,WAE5B,MAAMC,EAAW,IAAIC,SAAS,CAC1BC,UAAW,SACXC,YAAY,EACZC,aAAa,EACbC,eAAgB,KAGpB,SAASC,IACD,MAAMC,EAAiBC,EAAE,YAAYC,SAASC,IACxCC,EAAoBH,EAAE,YAAYC,SAASC,IAAMF,EAAE,YAAYI,cAC/DC,EAAmBL,EAAEV,QAAQgB,YAAcN,EAAEV,QAAQiB,cACrDC,EAAgBR,EAAEV,QAAQgB,YAE3BD,EAAmBN,GAAoBS,EAAgBL,EAExDX,EAASiB,gBAGTjB,EAASkB,iBAIjBpB,OAAOC,iBAAiB,SAAUO,GAAO,EAAO,CAACa,SAAS,IAG9D,MAAMC,EAAeC,SAASC,uBAAuB,SAAS,GAgBxDC,EAAQvB,EAASwB,SAASJ,EAbjB,CACXK,eAAgB,WAChBC,iBAAkB,WAClBC,SAAU,CACNC,KAAM,CACFC,KAAM,QACNC,KAAM,KACNC,MAAO,MAQnB,IAAIC,EAAU,IACVC,EAAc,GACdC,EAAc,EAClB1B,EAAE,YAAY2B,QAAO,WACjB7B,IACI4B,EAAc,KACdA,GAAe,IACfD,EAAc,OAItB,IAAIG,EAAY,IAChB5B,EAAE,YAAY6B,GAAG,0BAA0B,WACvCD,EAAY,OAGhB,IAAIE,GAAO,EAGPf,GACIA,EAAMgB,UAAS,WACPD,IACA9B,EAAE,YAAYgC,QAAQ,eACtBF,GAAO,GAGPN,EAAU,GAGNT,EAAMI,SAASC,KAAKG,OAFpBC,EAAU,GAEmB,IAGA,KAEjCA,KAEIE,EAAc,GACdD,GAAe,KACfV,EAAMI,SAASC,KAAKG,OAAU,EAAIE,EAClCC,IACoB,IAAhBA,IACAE,EAAY,OAGbA,EAAY,MACXA,GAAwB,KAE5Bb,EAAMI,SAASC,KAAKG,OAASK,QAMlD,CAACjB,SAAS","sourcesContent":["window.addEventListener(\"load\", function() {\n    // set up our WebGL context and append the canvas to our wrapper\n    const curtains = new Curtains({\n        container: \"canvas\",\n        autoResize: true,\n        watchScroll: false,\n        renderingScale: 0.3\n    });\n    \n    function check() {\n            const top_of_element = $(\".curtain\").offset().top;\n            const bottom_of_element = $(\".curtain\").offset().top + $(\".curtain\").outerHeight();\n            const bottom_of_screen = $(window).scrollTop() + $(window).innerHeight();\n            const top_of_screen = $(window).scrollTop();\n\n            if ((bottom_of_screen > top_of_element) && (top_of_screen < bottom_of_element)) {\n                // the element is visible, do something\n                curtains.enableDrawing();\n            } else {\n                // the element is not visible, do something else\n                curtains.disableDrawing();\n            }\n        }\n\n        window.addEventListener(\"scroll\", check, false, {passive: true});\n    \n    // get our plane element\n    const planeElement = document.getElementsByClassName(\"plane\")[0];\n    \n    // set our initial parameters (basic uniforms)\n    const params = {\n        vertexShaderID: \"plane-vs\", // our vertex shader ID\n        fragmentShaderID: \"plane-fs\", // our fragment shader ID\n        uniforms: {\n            time: {\n                name: \"uTime\", // uniform name that will be passed to our shaders\n                type: \"1f\", // this means our uniform is a float\n                value: 0,\n            },\n        },\n    };\n    \n    // create our plane\n    const plane = curtains.addPlane(planeElement, params);\n    \n    let initial = 500;\n    let incrementer = 0.5;\n    let scrollSpeed = 0;\n    $('.curtain').scroll(function () {\n        check();\n        if (scrollSpeed < 28) { // prevent too flickery animation loops\n            scrollSpeed += 1.5;\n            incrementer = 0.5;\n        }\n    });\n\n    let baseSpeed = 0.05;\n    $('.curtain').on('increaseAnimationSpeed', function () {\n        baseSpeed = 0.07;\n    });\n    \n    let once = true;\n    \n    // if our plane has been successfully created\n    if (plane) {\n            plane.onRender(function () {\n                if (once) {\n                    $('.curtain').trigger('canvasReady');\n                    once = false;\n                }\n                // use the onRender method of our plane fired at each requestAnimationFrame call\n                if (initial > 0) {\n                    if (initial < 10) {\n                        // plane.uniforms.time.value += 0.5;\n                        plane.uniforms.time.value += 0.15;\n                    } else {\n                        // plane.uniforms.time.value += 0.75;\n                        plane.uniforms.time.value += 0.175;\n                    }\n                    initial--;\n                } else {\n                    if (scrollSpeed > 0) {\n                        incrementer += .035;\n                        plane.uniforms.time.value += (1 / incrementer);\n                        scrollSpeed--;\n                        if (scrollSpeed === 0) {\n                            baseSpeed = 1.2;\n                        }\n                    } else {\n                        if(baseSpeed > 0.07) {\n                            baseSpeed = baseSpeed - 0.05;\n                        }\n                        plane.uniforms.time.value += baseSpeed; // update our time uniform value\n                    }\n                }\n            });\n        }\n    \n}, {passive: true});\n\n\n\n// window.onload = function() {\n//   // set up our WebGL context and append the canvas to our wrapper\n//   var webGLCurtain = new Curtains({\n//     container: \"canvas\",\n//     autoResize: true,\n//     watchScroll: false,\n//     renderingScale: 0.5\n//   });\n// \n//   // if there's any error during init, we're going to catch it here\n//   webGLCurtain.onError(function() {\n//     // we will add a class to the document body to display original images\n//     document.body.classList.add(\"no-curtains\");\n//   });\n// \n//   // get our plane element\n//   var planeElement = document.getElementsByClassName(\"plane\")[0];\n// \n//   // set our initial parameters (basic uniforms)\n//   var params = {\n//     vertexShaderID: \"plane-vs\", // our vertex shader ID\n//     fragmentShaderID: \"plane-fs\", // our framgent shader ID\n//     //crossOrigin: \"\", // codepen specific\n//     uniforms: {\n//       time: {\n//         name: \"uTime\", // uniform name that will be passed to our shaders\n//         type: \"1f\", // this means our uniform is a float\n//         value: 0,\n//       },\n//     }\n//   }\n// \n//   // create our plane mesh\n//   var plane = webGLCurtain.addPlane(planeElement, params);\n// \n//   // if our plane has been successfully created\n//   // we use the onRender method of our plane fired at each requestAnimationFrame call\n//   plane && plane.onRender(function() {\n//     plane.uniforms.time.value++; // update our time uniform value\n//   });\n// \n// }"]}